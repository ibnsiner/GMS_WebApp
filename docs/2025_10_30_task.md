# 복합 질의 처리 개선 - 최종 실행 방안

> **작성일**: 2025-10-30  
> **목적**: Multi-part query 처리 안정화  
> **현재 상태**: stable-e6ef5f6 브랜치 (안정)  
> **목표**: 기존 기능 보호하면서 복합 질의 지능적 처리

---

## 🔍 문제 상황

### 증상

**잘 작동하던 것**:
```
질문: "전선의 2023년 순이익, 영업이익, 자본총계를 알려줘"
결과: ✅ 하나의 쿼리로 즉시 처리, 완벽한 답변
```

**Multi-part strategy 추가 후 발생한 문제**:
```
같은 질문: "전선의 2023년 순이익, 영업이익, 자본총계를 알려줘"
LLM 응답: "3가지 subtask입니다..."
결과: ❌ 멈춤, 답변 없음
```

### 근본 원인

**1. 과도한 복잡도 감지**:
- LLM이 "여러 개 = 복잡함"으로 오해
- 단순한 IN 절로 해결 가능한 질문도 복잡하다고 판단

**2. Plan-only 문제**:
- 계획은 세우지만 실행하지 않음
- 첫 응답이 텍스트로 끝나면 멈춤

**3. 불명확한 기준**:
- "얼마나 복잡한가?"에 대한 모호한 판단
- Type A/B/C 분류가 LLM에게 혼란

---

## 💡 해결 전략: 2-Tier Decision Tree

### 핵심 아이디어

**LLM의 "판단"을 최소화하고 "규칙"을 따르게 함**

1. ✅ 명확한 이분법적 기준
2. ✅ 모호한 중간 단계 제거
3. ✅ 기존 작동 보호

### 2-Tier 모델

```
User Query
    ↓
[Tier 1] IMPOSSIBLE 체크
    ├─ 다른 시간 단위? (월별 AND 분기별)
    ├─ 다른 데이터 레벨? (전사 AND 사업별)
    ├─ YES → 사용자에게 분리 요청 → STOP
    └─ NO → Tier 2로
         ↓
[Tier 2] SOLVABLE (모든 나머지 경우)
    └─ Plan-then-Execute
        ├─ Simple → 1개 쿼리 (IN 절)
        └─ Complex → 여러 쿼리 순차 실행
```

### Tier 1: IMPOSSIBLE (반드시 분리)

**판단 기준** (둘 중 하나라도 해당):
- 서로 다른 시간 단위 혼합
- 서로 다른 데이터 레벨 혼합

**예시**:
```
❌ "월별 매출액과 분기별 영업이익"
❌ "전사 매출과 사업별 매출"  
❌ "연간 합계와 1분기 상세"
```

**행동**:
```
"요청하신 내용은 월별 데이터와 분기별 데이터가 혼합되어 있어 
한 번에 처리하기 어렵습니다. 번거로우시겠지만 나누어 질문해주시겠어요?

1. [회사]의 월별 매출액 추이
2. [회사]의 분기별 영업이익 합계

먼저 어느 것을 확인하시겠습니까?"
```

### Tier 2: SOLVABLE (Plan & Execute)

**판단 기준**:
- Tier 1이 아닌 모든 경우
- 단순하든 복잡하든 해결 가능

**예시**:
```
✅ "전선의 순이익, 영업이익, 자본총계" (Simple)
✅ "제조4사의 2023년 매출액과 영업이익" (Simple)
✅ "MnM과 엠트론의 매출액" (Simple)
✅ "제조4사 매출액과 전선 부채비율" (Complex but solvable)
✅ "2022년과 2023년 매출액 비교" (Same granularity)
```

**행동**:
```
Turn 1: 
  Thought: "My plan: 1. Query [...] 2. Present results"
  Tool Call: run_cypher_query(...)

Turn 2: 
  Final answer
```

**CRITICAL**:
- 첫 응답 = 계획 텍스트 + Tool 호출 (동시에!)
- 계획만 출력하고 멈추면 FAILED

---

## 🛠️ 구현 계획

### Phase 1: 안전한 작업 환경 준비

#### 1.1 브랜치 전략 수립

```bash
# 현재 위치 확인
git branch
# 출력: * stable-e6ef5f6

# Main 브랜치로 이동
git checkout main

# Stable의 안정적인 변경사항을 main에 병합
git merge stable-e6ef5f6 --no-ff -m "Merge stable-e6ef5f6 into main"

# 충돌 발생 시 해결 후:
# git add .
# git commit -m "Resolve merge conflicts"

# Main 브랜치 푸시
git push origin main

# 실험용 새 브랜치 생성
git checkout -b feature/2-tier-query-judgement

# 확인
git branch
# 출력: * feature/2-tier-query-judgement
```

#### 1.2 물리적 복사 (선택사항, 최고 안전)

```bash
# Windows 탐색기에서:
1. GMS_WebApp 폴더 전체 복사
2. GMS_WebApp_Experiment로 이름 변경
3. VS Code/Cursor로 GMS_WebApp_Experiment 폴더 열기
4. 모든 작업은 이 복사본에서만 진행
```

---

### Phase 2: System Prompt 수정 (핵심)

#### 2.1 수정할 파일 위치

```
파일: packages/backend/agent.py
함수: _create_system_prompt() (약 196줄)
수정 대상: Multi-Part Query 관련 섹션
```

#### 2.2 현재 코드 찾기

`_create_system_prompt()` 함수에서 다음 부분을 찾으세요 (약 202-226줄):

```python
**🚨 CRITICAL: Multi-Part Query Handling 🚨**

When user asks for MULTIPLE distinct data pieces in ONE question:
Example: "월별 매출액 추이 AND 분기별 영업이익 합계"

**BEST PRACTICE: Ask user to split the question**
...
```

#### 2.3 교체할 최종 코드

위에서 찾은 섹션을 **아래 코드로 완전히 교체**:

```python
**🚨 Multi-Part Query: 2-Tier Decision Tree 🚨**

When user asks for multiple pieces of data, follow this MANDATORY decision process:

**TIER 1: IMPOSSIBLE Query (Must Ask User to Split)**

Criteria - Check if ANY of these conditions are TRUE:
1. Request mixes DIFFERENT time granularities:
   - "월별" AND "분기별"
   - "연간" AND "월별"  
   - "상반기" AND "1분기"

2. Request mixes DIFFERENT data levels:
   - "전사" (CORPORATE) AND "사업별" (SEGMENT)
   - "Company total" AND "Business segment details"

Examples of IMPOSSIBLE queries:
❌ "MnM의 월별 매출액과 분기별 영업이익"
❌ "전선의 전사 매출과 사업별 매출"
❌ "연간 합계와 1분기 상세"

Your Action for IMPOSSIBLE:
Stop immediately and respond:
```
귀하의 질문에는 [월별 데이터와 분기별 데이터/전사 데이터와 사업별 데이터]가 
혼합되어 있어 한 번에 처리하기 어렵습니다. 

번거로우시겠지만 나누어 질문해주시겠어요?
1. [회사]의 [시간단위] [첫 번째 항목]
2. [회사]의 [시간단위] [두 번째 항목]

먼저 어느 것을 확인하시겠습니까?
```
DO NOT proceed to Tier 2. STOP here.

**TIER 2: SOLVABLE Query (Plan & Execute)**

Criteria:
- Everything NOT classified as IMPOSSIBLE in Tier 1
- Includes ALL of these:
  * Multiple accounts for same companies: "순이익, 영업이익, 자본총계"
  * Multiple companies for same accounts: "MnM과 엠트론의 매출액"
  * Same time period: "2022년과 2023년 매출액"
  * Mixed but solvable: "제조4사 매출액과 전선 부채비율"

Examples of SOLVABLE queries:
✅ "전선의 2023년 순이익, 영업이익, 자본총계" (Simple - 1 query with IN)
✅ "제조4사의 2023년 매출액과 영업이익" (Simple - 1 query with IN)
✅ "MnM과 엠트론의 당기순이익" (Simple - 1 query with IN)
✅ "MnM의 2022년과 2023년 매출액 비교" (Simple - 1 query, 2 years - SAME granularity)
✅ "제조4사 매출액과 전선 부채비율" (Complex - 2 queries)

**IMPORTANT**: "2022년과 2023년" is NOT different time granularities! 
Both are YEARLY data, just different years. This is Tier 2, NOT Tier 1.

Your Action for SOLVABLE:
Use Plan-then-Execute strategy. Your FIRST response **MUST** be structured exactly like the example below, containing BOTH a 'Thought' block and a 'Tool Call' block.

**--- EXAMPLE OF A PERFECT FIRST RESPONSE ---**
```
Thought:
This is a solvable query. My plan is:
1. Execute a single Cypher query using `WHERE a.id IN [...]` to get '순이익', '영업이익', and '자기자본_합계' for 'LS전선'.
2. Present the results to the user.

Now, I will execute Step 1.

Tool Call:
run_cypher_query(query="MATCH (c:Company {id: 'LSCNS_C'})-[:HAS_STATEMENT]->(fs:FinancialStatement) WHERE fs.id CONTAINS '2023' ... WHERE a.id IN ['당기순이익', '영업이익', '자기자본_합계'] ...")
```
**--- END OF EXAMPLE ---**

CRITICAL:
- Your response MUST follow this exact structure: Thought + Tool Call
- NEVER output the 'Thought' block alone and stop
- The 'Tool Call' block is MANDATORY in your first response
- If you output plan only, you FAILED the task
- Simple cases: One query with IN clause
- Complex cases: Multiple sequential queries

**Decision Process Summary:**
```
Is query IMPOSSIBLE? (Tier 1 check)
├─ YES → Ask user to split → STOP
└─ NO → SOLVABLE (Tier 2) → Plan & Execute
```
```

---

### Phase 3: 단계별 테스트 (매우 상세)

#### 3.1 환경 준비

```bash
# 백엔드 재시작 (필수!)
cd packages/backend
Ctrl+C  # 기존 프로세스 종료
run_backend.bat

# 프론트엔드 새로고침
브라우저에서 Ctrl + Shift + R

# New Chat 클릭하여 새 세션 시작
```

#### 3.2 Tier 2 검증 (기존 기능 - 최우선!)

**⚠️ CRITICAL: 하나라도 실패하면 즉시 중단 및 롤백!**

---

**Test 3.2.1: 여러 계정, 하나의 회사**

질문:
```
전선의 2023년 순이익, 영업이익, 자본총계를 알려줘
```

예상 백엔드 로그:
```
[INFO] Tool 호출: run_cypher_query
[INFO] Executing Cypher Query:
MATCH (c:Company {id: 'LSCNS_C'})-[:HAS_STATEMENT]->(fs:FinancialStatement)
WHERE fs.id CONTAINS '2023' AND fs.id CONTAINS 'ACTUAL'
...
WHERE a.id IN ['당기순이익', '영업이익', '자기자본_합계']
...
[INFO] 쿼리 성공: 36개 레코드
[INFO] 파싱된 컨텐츠 블록 수: 4
[INFO]   블록 1: type=table, columns=3, rows=12
```

예상 프론트엔드:
- ✅ 요약: 3개 항목 모두 언급
- ✅ 집계 테이블: InteractiveTable (CSV 다운로드 가능)
- ✅ 월별 상세: 3개 컬럼 모두 표시
- ✅ 응답 시간: 5-10초

**통과 기준**: 위 로그와 동일, 테이블 정상 렌더링

---

**Test 3.2.2: 여러 회사, 여러 계정**

질문:
```
제조4사의 2023년 매출액, 영업이익, 순이익을 모두 보여줘
```

예상 백엔드 로그:
```
[INFO] 그룹 '제조4사' (manufacturing_4)의 회사 목록: ['LSCNS_C', 'ELECTRIC', 'MnM', '엠트론']
[INFO] Tool 호출: run_cypher_query
[INFO] WHERE c.id IN ['LSCNS_C', 'ELECTRIC', 'MnM', '엠트론']
[INFO] WHERE (c.id IN ['LSCNS_C', 'ELECTRIC', '엠트론'] AND a.id IN [...])
       OR (c.id = 'MnM' AND a.id IN ['매출액_합계', '조정영업이익', '당기순이익'])
[INFO] 쿼리 성공: 144개 레코드
[INFO]   블록 1: type=table, columns=4, rows=4
```

예상 프론트엔드:
- ✅ 4개 회사 모두 표시 (전선, ELECTRIC, MnM, 엠트론)
- ✅ 집계 테이블: 4행 × 4컬럼
- ✅ 월별 상세: PIVOT 형식

**통과 기준**: 144개 레코드, 4개 회사 모두, 테이블 정상

---

**Test 3.2.3: 여러 회사, 하나의 계정**

질문:
```
MnM과 엠트론의 2023년 당기순이익
```

예상 백엔드 로그:
```
[INFO] 추출된 회사: {'mnm': 'MnM', '엠트론': '엠트론'}
[INFO] Tool 호출: run_cypher_query
[INFO] WHERE c.id IN ['MnM', '엠트론']
[INFO] WHERE a.id = '당기순이익'
[INFO] 쿼리 성공: 24개 레코드
```

예상 프론트엔드:
- ✅ 2개 회사 데이터
- ✅ 월별 비교 테이블

**통과 기준**: 24개 레코드, 2개 회사, 즉시 답변

---

#### 3.3 Tier 1 검증 (새 기능)

**Test 3.3.1: 시간 단위 혼합**

질문:
```
MnM의 2023년 월별 매출액과 분기별 영업이익을 보여줘
```

예상 백엔드 로그:
```
[INFO] ReAct Iteration 1/10
[INFO] 최종 답변 생성 완료
[INFO] 최종 답변 (파싱 전): 귀하의 질문에는 월별 데이터와 분기별 데이터가...
```

예상 프론트엔드:
```
귀하의 질문에는 월별 데이터와 분기별 데이터가 혼합되어 있어 
한 번에 처리하기 어렵습니다.

번거로우시겠지만 나누어 질문해주시겠어요?
1. MnM의 2023년 월별 매출액 추이
2. MnM의 2023년 분기별 영업이익 합계

먼저 어느 것을 확인하시겠습니까?
```

**통과 기준**: Tool 호출 없음, 안내 메시지만, 친절한 톤

---

**Test 3.3.2: 데이터 레벨 혼합**

질문:
```
전선의 전사 매출과 사업별 매출을 비교해줘
```

예상 프론트엔드:
```
귀하의 질문에는 전사 데이터와 사업별 데이터가 혼합되어 있어 
한 번에 처리하기 어렵습니다.

번거로우시겠지만 나누어 질문해주시겠어요?
1. 전선의 전사 매출
2. 전선의 사업별 매출

먼저 어느 것을 확인하시겠습니까?
```

**통과 기준**: Tool 호출 없음, 안내 메시지

---

#### 3.4 Edge Cases (애매한 경우)

**Test 3.4.1: 여러 연도**

질문:
```
MnM의 2022년과 2023년 매출액 비교
```

예상 분류: Tier 2 (같은 granularity - 연간)

예상 백엔드 로그:
```
[INFO] WHERE (fs.id CONTAINS '2022' OR fs.id CONTAINS '2023')
[INFO] 쿼리 성공: 48개 레코드
```

예상 프론트엔드:
- ✅ 집계 테이블에 p.year 컬럼
- ✅ 2022년과 2023년 데이터 모두 표시

**통과 기준**: 두 연도 모두 표시, 비교 가능한 테이블

---

**Test 3.4.2: 분기 + 반기 혼합**

질문:
```
전선의 1분기와 상반기 매출액
```

예상 분류: Tier 2 (모두 집계 단위, 해결 가능)

예상 행동: 
- Quarter와 HalfYear 노드 활용 시도
- 또는 "더 구체적으로 질문해주세요" 안내

**통과 기준**: 에러 없이 처리 (답변 or 안내)

---

**Test 3.4.3: 전체 데이터**

질문:
```
전선의 2023년 모든 재무 데이터
```

예상 분류: Tier 2

예상 행동:
- 여러 계정 조회
- 또는 "구체적인 항목을 지정해주세요" 안내

**통과 기준**: 합리적인 응답

---

#### 3.5 회귀 테스트 (기존 기능 재확인)

프롬프트 수정 후 다시 한번:

```bash
# 차트 기능
"MnM의 2024년 월별 매출액을 그래프로 그려줘"
→ 기대: 차트 인라인 표시

# 추세선
"추세선을 포함해줘"
→ 기대: 점선 추세선 추가

# 연도 필터
"2022년 데이터만 그래프로"
→ 기대: 2022년만 표시

# 계획-실적 비교 (이미 구현된 Phase 1)
"2023년 일렉트릭 매출액 계획 대비 실적"
→ 기대: plan, actual, variance_pct 컬럼

# ROE 계산 (Phase 3)
"MnM의 2023년 ROE를 계산해줘"
→ 기대: 자동 계산 결과
```

**통과 기준**: 모두 정상 작동

### Phase 4: 문제 발생 시 즉시 대응

#### 4.1 롤백 절차

**즉시 중단 조건**:
- Test 3.2.1, 3.2.2, 3.2.3 중 하나라도 실패
- 백엔드 에러 발생
- 응답이 나오지 않음
- 테이블 렌더링 깨짐

**롤백 명령**:
```bash
# 현재 변경사항 폐기
git reset --hard HEAD~1

# 또는 특정 커밋으로
git log --oneline -5
git reset --hard <좋았던 커밋 해시>

# 안전한 브랜치로 복귀
git checkout stable-e6ef5f6

# 백엔드 재시작
run_backend.bat
```

#### 4.2 로그 저장

**매 테스트마다**:
```bash
# 백엔드 로그 전체 복사
# 파일로 저장: test_3.2.1_log.txt

# 프론트엔드 스크린샷
# 파일: test_3.2.1_screenshot.png

# 브라우저 콘솔 캡처
F12 → Console → 우클릭 → Save as
```

#### 4.3 문제 분석 템플릿

```markdown
## 테스트 실패 보고

**Test**: 3.2.1 (전선의 순이익, 영업이익, 자본총계)
**증상**: [설명]
**백엔드 로그**: [첨부 또는 복사]
**프론트엔드**: [스크린샷]
**예상**: [무엇을 기대했는지]
**실제**: [무엇이 발생했는지]

## 원인 분석
[...]

## 해결 방안
[...]
```

---

### Phase 5: 성공 시 통합 전략

#### 5.1 최종 검증

**모든 테스트 통과 확인**:
```
✅ Test 3.2.1, 3.2.2, 3.2.3 (기존 기능)
✅ Test 3.3.1, 3.3.2 (Tier 1 안내)
✅ Test 3.4.1, 3.4.2, 3.4.3 (Edge cases)
✅ Test 3.5 (회귀 테스트 - 차트, ROE 등)
```

#### 5.2 Main 브랜치 통합

```bash
# 현재 브랜치 확인
git branch
# * feature/2-tier-query-judgement

# Main으로 이동
git checkout main

# 실험 브랜치 병합
git merge feature/2-tier-query-judgement --no-ff -m "Integrate 2-tier query judgement system"

# 푸시
git push origin main
```

#### 5.3 Stable 브랜치 업데이트

```bash
# Stable 브랜치로 이동
git checkout stable-e6ef5f6

# Main의 변경사항 가져오기
git merge main

# 푸시
git push origin stable-e6ef5f6
```

#### 5.4 정리 (선택사항)

```bash
# 로컬 실험 브랜치 삭제
git branch -d feature/2-tier-query-judgement

# 원격 실험 브랜치 삭제
git push origin --delete feature/2-tier-query-judgement
```

---

## 🔧 문제 해결 가이드

### 문제 1: "계획만 세우고 멈춤"

**증상**:
```
[INFO] 최종 답변: "My plan: 1. ... 2. ..."
[INFO] Tool 호출 없음
```

**원인**: Plan-then-Execute 지시가 약함

**해결**:
```python
# System Prompt에 더 강력한 문구 추가
"CRITICAL: Your first response MUST include tool call.
If you output plan only, you FAILED.
Example wrong: 'My plan: ...' (no tool call) ❌
Example right: 'My plan: ...' + run_cypher_query(...) ✅"
```

---

### 문제 2: "단순한 질문도 복잡하다고 판단"

**증상**:
```
질문: "전선의 순이익, 영업이익"
응답: "2가지 subtask로 나눠..."
```

**원인**: Tier 1 조건이 너무 광범위

**해결**:
```python
# Tier 1 기준을 더 구체적으로
"ONLY if DIFFERENT TIME GRANULARITIES:
- monthly AND quarterly ← Tier 1
- multiple accounts ← Tier 2 (NOT Tier 1)"
```

---

### 문제 3: "테이블 파싱 실패"

**증상**:
```
[INFO] 블록 1: type=text (should be table)
```

**원인**: 테이블 감지 로직 버그

**해결**:
- 로그에서 실제 섹션 내용 확인
- 테이블 패턴 디버깅
- 파싱 로직 재검토

---

## 📊 성공 지표

### 정량적 지표

**응답 시간**:
- 단순 질문: < 10초
- 복잡한 질문: < 30초
- Tier 1 안내: < 5초

**정확도**:
- 기존 기능 테스트: 100% 통과
- Tier 1 감지: 100% 정확
- Tier 2 실행: 95% 이상 성공

**렌더링**:
- 테이블 파싱: 100% (type=table)
- InteractiveTable 표시: 100%

### 정성적 지표

- ✅ 사용자 불편 없음
- ✅ 답변 품질 유지
- ✅ 에러 메시지 친절함
- ✅ 로그 명확성

---

---

## 📝 실행 체크리스트 (순서대로 진행)

### Day 1: 환경 준비 및 구현
- [ ] **1-1**: `git checkout main`
- [ ] **1-2**: `git merge stable-e6ef5f6 --no-ff`
- [ ] **1-3**: 충돌 해결 (있는 경우)
- [ ] **1-4**: `git push origin main`
- [ ] **1-5**: `git checkout -b feature/2-tier-query-judgement`
- [ ] **1-6**: VS Code에서 `packages/backend/agent.py` 열기
- [ ] **1-7**: `_create_system_prompt()` 함수 찾기 (196줄)
- [ ] **1-8**: Multi-Part Query 섹션 찾기 (202-226줄)
- [ ] **1-9**: Phase 2.3의 코드로 교체
- [ ] **1-10**: 파일 저장
- [ ] **1-11**: `git add packages/backend/agent.py`
- [ ] **1-12**: `git commit -m "feat: Add 2-tier query judgement system"`
- [ ] **1-13**: 백엔드 재시작 (`run_backend.bat`)
- [ ] **1-14**: 프론트엔드 새로고침 (Ctrl+Shift+R)

### Day 2: 기존 기능 테스트 (절대 우선순위!)
- [ ] **2-1**: New Chat 시작
- [ ] **2-2**: Test 3.2.1 실행
  - [ ] 질문 입력
  - [ ] 백엔드 로그 복사 → 저장
  - [ ] 프론트엔드 스크린샷
  - [ ] 통과 기준 확인
  - [ ] ✅ PASS / ❌ FAIL 기록
- [ ] **2-3**: Test 3.2.2 실행 (동일 절차)
- [ ] **2-4**: Test 3.2.3 실행 (동일 절차)
- [ ] **2-5**: ⚠️ 하나라도 FAIL → Phase 4 롤백으로 즉시 이동
- [ ] **2-6**: 모두 PASS → 다음 단계 진행

### Day 3: 새 기능 테스트
- [ ] **3-1**: Test 3.3.1 실행 (Tier 1 - 시간 혼합)
  - [ ] 백엔드 로그 확인 (Tool 호출 없어야 함)
  - [ ] 안내 메시지 확인
  - [ ] ✅ PASS / ❌ FAIL
- [ ] **3-2**: Test 3.3.2 실행 (Tier 1 - 레벨 혼합)
- [ ] **3-3**: Test 3.4.1 실행 (Edge - 여러 연도)
- [ ] **3-4**: Test 3.4.2 실행 (Edge - 분기+반기)
- [ ] **3-5**: Test 3.4.3 실행 (Edge - 전체 데이터)

### Day 4: 회귀 테스트
- [ ] **4-1**: Test 3.5 - 차트 기능
- [ ] **4-2**: Test 3.5 - 추세선
- [ ] **4-3**: Test 3.5 - 연도 필터
- [ ] **4-4**: Test 3.5 - 계획-실적 비교
- [ ] **4-5**: Test 3.5 - ROE 계산

### Day 5: 통합 및 배포
- [ ] **5-1**: 모든 테스트 결과 취합
- [ ] **5-2**: 문제 있으면 수정 및 재테스트
- [ ] **5-3**: 모두 PASS 확인
- [ ] **5-4**: `git checkout main`
- [ ] **5-5**: `git merge feature/2-tier-query-judgement --no-ff`
- [ ] **5-6**: `git push origin main`
- [ ] **5-7**: `git checkout stable-e6ef5f6`
- [ ] **5-8**: `git merge main`
- [ ] **5-9**: `git push origin stable-e6ef5f6`
- [ ] **5-10**: 프로덕션 배포 (있는 경우)

---

## 🚨 안전 수칙

### DO
✅ 한 번에 하나씩만 변경
✅ 매 단계마다 커밋
✅ 테스트 실패 시 즉시 중단
✅ 로그 저장 및 분석

### DON'T
❌ 여러 변경사항 동시 적용
❌ 테스트 건너뛰기
❌ 문제 있는데 계속 진행
❌ Main 브랜치 직접 수정

---

## 📊 예상 결과

### 성공 시

**기존 질문** (변화 없음):
```
"전선의 순이익, 영업이익, 자본총계"
→ 쿼리 1개, 응답 5초, 완벽한 테이블
```

**복잡한 질문** (개선):
```
"월별 매출액과 분기별 영업이익"  
→ 친절한 안내, 사용자가 나눠 질문
→ 각각 정확한 답변
```

### 실패 시

```bash
# 즉시 롤백
git reset --hard <이전 커밋>
git checkout stable-e6ef5f6

# 원인 분석 후 재시도
```

---

## 💬 Google AI Studio 검토 요청 사항

### 질문 1: 2-Tier 모델의 판단 기준

**현재 Tier 1 (IMPOSSIBLE) 기준**:
- 다른 시간 단위: "월별" AND "분기별"
- 다른 데이터 레벨: "전사" AND "사업별"

**검토 요청**:
1. 이 기준이 충분히 명확하고 포괄적인가?
2. 추가해야 할 IMPOSSIBLE 조건이 있는가?
   - 예: "계획" AND "실적"? → 현재는 Tier 2로 처리 가능
   - 예: "IS" AND "BS" 동시? → 현재 하나의 쿼리로 가능
3. 놓친 Edge Case는 없는가?

---

### 질문 2: Plan-then-Execute 강제 방법

**현재 문구**:
```
"Your FIRST response must include BOTH:
1. Your Plan (in thought)
2. Tool Call (immediately after plan)

NEVER output plan text only without tool call"
```

**문제 현상**:
- LLM이 계획만 출력하고 멈춤
- 첫 응답이 텍스트만 포함

**검토 요청**:
1. 이 문구가 충분히 강력한가?
2. Gemini Function Calling에서 더 확실한 방법은?
3. 시스템 설정으로 강제할 수 있는가?
   - `tool_choice` 파라미터?
   - `response_schema`?

---

### 질문 3: Edge Cases 처리 가이드

**Case 1: 여러 연도**
```
"2022년과 2023년 매출액"
```
- 현재: Tier 2 (같은 granularity)
- 권장: 맞는가? 다른 처리 방법?

**Case 2: 분기 + 반기**
```
"1분기와 상반기 매출액"
```
- 현재: Tier 2 시도
- 권장: Tier 1? Tier 2? 거부?

**Case 3: 계획 vs 실적**
```
"2023년 매출액 계획과 실적"
```
- 현재: Tier 2 (COMPARISON_FOR 관계 사용)
- 권장: 맞는가?

**Case 4: 모든 데이터**
```
"전선의 2023년 모든 재무 데이터"
```
- 현재: Tier 2 (여러 쿼리 시도)
- 권장: 범위 제한 안내? 그대로 진행?

**검토 요청**:
- 각 Case의 권장 Tier는?
- 추가로 고려해야 할 Case는?

---

### 질문 4: 프롬프트 최적화

**현재 상태**:
- System Prompt: ~450줄
- 매우 상세하지만 길 수 있음

**검토 요청**:
1. 길이가 Gemini 2.5-flash 성능에 영향을 주는가?
2. 줄일 수 있는 섹션은?
   - 예시가 너무 많은가?
   - 중복된 설명이 있는가?
3. 핵심만 남기고 줄이는 전략은?

---

### 질문 5: 대안 접근법

**현재 방식의 한계**:
- LLM이 "계획"과 "Tool 호출"을 동시에 하도록 강제하기 어려움
- Gemini API 레벨에서 강제하는 방법이 없는 것 같음

**검토 요청**:
1. **완전히 다른 접근법**이 있는가?
   - 예: Python에서 질문을 먼저 파싱?
   - 예: 정규식으로 "월별 AND 분기별" 감지?
   - 예: LLM 호출 전에 전처리?

2. **Gemini API 고급 기능** 활용?
   - Grounding?
   - Context caching?
   - Tool config 옵션?

3. **Multi-Agent 패턴**?
   - Query Planner Agent (계획만)
   - Executor Agent (실행만)
   - 분리하는 것이 나은가?

4. **더 나은 프롬프트 패턴**?
   - Chain-of-Thought?
   - Few-shot examples?
   - 다른 방식?

---

## 📌 핵심 결정 사항

### 구현 전 합의 필요

**Q1**: 2-Tier vs 3-Tier?
- [ ] 2-Tier (IMPOSSIBLE vs SOLVABLE) ← 현재 제안
- [ ] 3-Tier (IMPOSSIBLE vs COMPLEX vs SIMPLE)
- [ ] 다른 모델

**Q2**: Type B (Complex SOLVABLE) 필요한가?
- [ ] 필요 (3-Tier)
- [ ] 불필요 (2-Tier로 충분)

**Q3**: Plan-then-Execute 계속 시도?
- [ ] 계속 시도 (프롬프트 강화)
- [ ] 포기 (단순 질문만 처리, 복잡한 건 안내)
- [ ] Python 전처리로 대체

**Q4**: 실험 환경?
- [ ] Git 브랜치만
- [ ] 물리적 폴더 복사도
- [ ] 둘 다

---

## 📅 타임라인

**Week 1 (현재)**:
- Day 1-2: Google 검토 및 피드백 대기
- Day 3-4: 피드백 반영, 최종 방안 확정
- Day 5: 구현 시작

**Week 2**:
- Day 1-3: 테스트 (체크리스트 진행)
- Day 4: 문제 수정
- Day 5: 최종 통합

---

**작성자**: GMS_WebApp Development Team  
**검토 요청 대상**: Google AI Studio  
**우선 검토 요청**: 질문 2, 3, 5 (가장 불확실한 부분)  
**다음 단계**: 검토 결과 반영 → 최종 방안 확정 → 구현 시작

---

## 📎 참고 자료

**관련 문서**:
- `docs/CONFIG_UTILIZATION_ROADMAP.md` - Phase 1-8 구현 로드맵
- `docs/TECHNICAL_DOCUMENTATION.md` - 기술 문서
- `README.md` - 회계 원리 설명

**관련 커밋**:
- `e6ef5f6` - 안정 버전 (현재 stable 브랜치)
- `4701453` - Phase 1-8 구현 (main 브랜치, 일부 불안정)

**브랜치 구조**:
```
origin/main (실험적)
  └─ Phase 1-8 구현됨

origin/stable-e6ef5f6 (안정)
  └─ CLI 제거, 테이블 파싱 수정
  └─ 프로덕션 준비 완료
```

